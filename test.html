<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<style>
/*	style definitions	*/
button {
  position: absolute;
}

#blue {
  top: 1em;
  left: 1em;
}

#orange {
  top: 1em;
  left: 8em;
}

#green {
  top: 1em;
  left: 16em;
}

.node {
	stroke: white;
	stroke-width: 2px;
}

.link {
	stroke: gray;
	stroke-width: 4px;
}

</style>
<svg width="960" height="500"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script
  src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>
<script>

//	data stores
var graph = {}, store = {};

//	svg selection and sizing
var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height"),
    radius = 10;

//	d3 color scales
var color = d3.scaleOrdinal(d3.schemeCategory10);

var link = svg.append("g").selectAll(".link"),
	node = svg.append("g").selectAll(".node");

//	force simulation initialization
var simulation = d3.forceSimulation()
	.force("link", d3.forceLink()
		.id(function(d) { return d.id; }))
	.force("charge", d3.forceManyBody()
		.strength(function(d) { return -500;}))
	.force("center", d3.forceCenter(width / 2, height / 2));

//	filtered types
typeFilterList = [];

//	data read and store
d3.xml("tracery.xml", function(err, links) {
	if (err) throw err;

	var results = links.querySelectorAll("result")
  results = [].slice.call(results)
  results = results.map(function(triplet) {
    function getVar(name) {
      var r = triplet.querySelector("[name=" + name + "] uri")
      if (!r || r.childNodes.length == 0) return undefined
      return r.childNodes[0].nodeValue
    }
    return {
      subject: getVar("subject"),
      predicate: getVar("predicate"),
      object: getVar("object")
    }
  });

  var nodes = {},
    links = results.filter(function(link) {
      return link.subject && link.predicate && link.object
    })
  links.forEach(function(link) {
    link.source = nodes[link.subject] || (
      nodes[link.subject] = {name: link.subject, links: [], depth: 0}
    )
    link.source.links.push(link)
    link.target = nodes[link.object] || (
      nodes[link.object] = {name: link.object, links: [], depth: 0}
    )
    link.depth = 0
    link.target.links.push(link)
  })

	graph.nodes = store.nodes = d3.values(nodes)
	graph.links1 = store.links1 = links

	update()
});

//	general update pattern for updating the graph
function update() {
	//	UPDATE
	node = node.data(graph.nodes, function(d) { return d.id;});
	//	EXIT
	node.exit().remove();
	//	ENTER
	var newNode = node.enter().append("circle")
		.attr("class", "node")
		.attr("r", radius)
		.attr("fill", function(d) {return color(d.group);})

    newNode.append("title")
      .text(function(d) { return "group: " + d.group + "\n" + "id: " + d.id; });
	//	ENTER + UPDATE
	node = node.merge(newNode);

	//	UPDATE
	link = link.data(graph.links1, function(d) { return d.id;});
	//	EXIT
	link.exit().remove();
	//	ENTER
	newLink = link.enter().append("line")
		.attr("class", "link");

	newLink.append("title")
      .text(function(d) { return "source: " + d.source + "\n" + "target: " + d.target; });
	//	ENTER + UPDATE
	link = link.merge(newLink);

	//	update simulation nodes, links, and alpha
	simulation
		.nodes(graph.nodes)
		.on("tick", ticked);

  	simulation.force("link")
  		.links(graph.links1);

  	simulation.alpha(1).alphaTarget(0).restart();
}

//	tick event handler with bounded box
function ticked() {
	node
		.attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
		.attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });

	link
		.attr("x1", function(d) { return d.source.x; })
		.attr("y1", function(d) { return d.source.y; })
		.attr("x2", function(d) { return d.target.x; })
		.attr("y2", function(d) { return d.target.y; });
}

//	filter function
function filter() {
	//	add and remove nodes from data based on type filters
	store.nodes.forEach(function(n) {
		if (!typeFilterList.includes(n.group) && n.filtered) {
			n.filtered = false;
			graph.nodes.push($.extend(true, {}, n));
		} else if (typeFilterList.includes(n.group) && !n.filtered) {
			n.filtered = true;
			graph.nodes.forEach(function(d, i) {
				if (n.id === d.id) {
					graph.nodes.splice(i, 1);
				}
			});
		}
	});

	//	add and remove links from data based on availability of nodes
	store.links1.forEach(function(l) {
		if (!(typeFilterList.includes(l.sourceGroup) || typeFilterList.includes(l.targetGroup)) && l.filtered) {
			l.filtered = false;
			graph.links1.push($.extend(true, {}, l));
		} else if ((typeFilterList.includes(l.sourceGroup) || typeFilterList.includes(l.targetGroup)) && !l.filtered) {
			l.filtered = true;
			graph.links1.forEach(function(d, i) {
				if (l.id === d.id) {
					graph.links1.splice(i, 1);
				}
			});
		}
	});			
}

</script>
