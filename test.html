<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<style>
/*	style definitions	*/
button {
  position: absolute;
}

#blue {
  top: 1em;
  left: 1em;
}

#orange {
  top: 1em;
  left: 8em;
}

#green {
  top: 1em;
  left: 16em;
}

.node {
	fill: white;
	stroke-width: 2px;
}

.link {
    fill: none;
	stroke: gray;
	stroke-width: 2px;
}
.linkLabel text {
    fill: gray;
    font-size: 50%;
    font-style: italic;
    stroke: none;
}

</style>

<svg width="960" height="500"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

//	data stores
var graph = {nodes: [], links1: []}, store = {} , kindLabel = {};

//	svg selection and sizing
var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height"),
    radius = 20;

//	d3 color scales
// var color = d3.scaleOrdinal(d3.schemeCategory10);
var color = d3.scaleOrdinal()
.domain(["http://www.w3.org/ns/org#/Role", "http://erlangen-crm.org/current/E5_Event", "http://erlangen-crm.org/current/E21_Person", "http://erlangen-crm.org/current/E18_Physical_Thing", "http://erlangen-crm.org/current/E74_Group", "http://erlangen-crm.org/current/E53_Place", "http://erlangen-crm.org/current/E31_Document", "http://erlangen-crm.org/current/38_Image"])
.range(["#00FF00","#FF0000","#0000FF","#C0C0C0","#00FFFF","#FFFF00","#008080","#FF00FF"]);



var link = svg.append("g").selectAll(".link"),
	node = svg.append("g").selectAll(".node");

//	force simulation initialization
var simulation = d3.forceSimulation()
	.force("link", d3.forceLink()
           .distance(60)
		.id(function(d) { return d.id; }))
	.force("charge", d3.forceManyBody()
		.strength(function(d) { return -500;}))
	.force("center", d3.forceCenter(width / 2, height / 2));

//	filtered types
typeFilterList = [];

//  data read and store for kind and label
d3.xml("tracery_type_label.xml", function(err, links) {
   if (err) throw err;
   
   var results = links.querySelectorAll("result")
   results = [].slice.call(results)
   results = results.map(function(typeLabel) {
     function getVar(name) {
         var r = typeLabel.querySelector("[name=" + name + "] uri")
         if (!r || r.childNodes.length == 0) return undefined
         return r.childNodes[0].nodeValue
     }
     function getVal(name) {
         var r = typeLabel.querySelector("[name=" + name + "] literal")
         if (!r || r.childNodes.length == 0) return undefined
         return r.childNodes[0].nodeValue
     }
     return {
         subject: getVar("subject"),
         kind: getVar("type"),
         label: getVal("label")
     }
  });

     var nodes = {},
        links = results.filter(function(link) {
          return link.subject
        })
        links.forEach(function(link) {
              nodes[link.subject] = link
        })
        kindLabel.nodes = nodes
        kindLabel.links1 = links
        update()
});
//	data read and store for triples
d3.xml("tracery.xml", function(err, links) {
	if (err) throw err;

	var results = links.querySelectorAll("result")
      results = [].slice.call(results)
      results = results.map(function(triplet) {
    function getVar(name) {
      var r = triplet.querySelector("[name=" + name + "] uri")
      if (!r || r.childNodes.length == 0) return undefined
      return r.childNodes[0].nodeValue
    }
                        
    return {
      subject: getVar("subject"),
      predicate: getVar("predicate"),
      object: getVar("object")
    }
  });

  var nodes = {},
    links = results.filter(function(link) {
      return link.subject && link.predicate && link.object
    })
  links.forEach(function(link) {
    link.source = nodes[link.subject] || (
      nodes[link.subject] = {name: link.subject, peers: [], filtered: true}
    )
    link.target = nodes[link.object] || (
      nodes[link.object] = {name: link.object, peers: [], filtered: true}
    )
    link.filtered = true
    if (link.source.peers.indexOf(link.target) < 0)
    	link.source.peers.push(link.target)
    if (link.target.peers.indexOf(link.source) < 0)
    	link.target.peers.push(link.source)
  })
  // For the sake of what's visible, each node is peered with itself.
  d3.values(nodes).forEach(function(node) {
		node.peers.push(node)
  })

	store.nodes = d3.values(nodes)
	store.links1 = d3.values(links)

	//filter(store.nodes[0].peers)
       filter(nodes["http://tracery.openwork.nz/data/people/eje"].peers)
	update()
       
});



//	general update pattern for updating the graph
function update() {
	//	UPDATE
	node = node.data(graph.nodes, function(d) { return d.id;});
	//	EXIT
	node.exit().remove();
	//	ENTER
	var newNode = node.enter().append("g")
        newNode.append("circle")
		.attr("class", "node")
		.attr("r", radius)
		.on("click", function(d) {
			filter(d.peers)
			update()
		})

    
    newNode.append("text")
        .attr("y", 1.5*radius)
        .attr("text-anchor", "middle")
        .attr("font-size", "50%")
        .text(function(d) {
          var labelling = kindLabel.nodes[d.name]
          if (!labelling) return d.name.split("/").pop()
          return labelling.label;
          })
      ;
	//	ENTER + UPDATE
    node = node.merge(newNode);
    node.select("circle").attr("stroke", function(d) {
          var labelling = kindLabel.nodes[d.name]
          if (!labelling) return "gray"
          return color(labelling.kind)
    })


	//	UPDATE
	link = link.data(graph.links1, function(d) { return d.id;});
	//	EXIT
	link.exit().remove();
	//	ENTER
	var newLink = link.enter().append("g").attr("class", "link")
  newLink.append("path")
    .attr("id", function(d, i) {return "link-" + i});


	newLink.append("g").attr("class", "linkLabel")
        .append("text")
        .append("textPath")
        .attr("xlink:href", function(d, i) {return "#link-" + i})
        .text(function(d) {
            var labelling = kindLabel.nodes[d.predicate]
              if (!labelling) {
              //.attr("fill", "red")
              return d.predicate.split("/").pop()}
            return labelling.label;
            });

            
	//	ENTER + UPDATE
	link = link.merge(newLink);
   // link.selectAll("text").data(links1).enter()
   
	//	update simulation nodes, links, and alpha
	simulation
		.nodes(graph.nodes)
		.on("tick", ticked);

  	simulation.force("link")
  		.links(graph.links1);

  	simulation.alpha(1).alphaTarget(0).restart();
}

//	tick event handler with bounded box
function ticked() {

    node.attr("transform", function(d) {
              return "translate(" + d.x + " " + d.y + ")"
              });

    link.select("path")
        .attr("d", function(d) {
              var dx = d.target.x - d.source.y,
              dy = d.target.y - d.source.y,
              dr = Math.sqrt(dx*dx + dy*dy)
              return "M" + d.source.x + "," + d.source.y +
              "A" + dr + "," + dr + " 0 0,1 " +
              d.target.x + "," + d.target.y
              })
}

//	filter function
function filter(focused, d) {
	//	add and remove nodes from data based on type filters
	store.nodes.forEach(function(n) {
		if (focused.indexOf(n) >= 0 && n.filtered) {
			n.filtered = false;
			graph.nodes.push(n);
		} else if (focused.indexOf(n) < 0 && !n.filtered) {
			n.filtered = true;
			graph.nodes.forEach(function(d, i) {
				if (n === d) {
					graph.nodes.splice(i, 1);
				}
			});
		}
	});

	//	add and remove links from data based on availability of nodes
	store.links1.forEach(function(l) {
		if (!(l.source.filtered || l.target.filtered) && l.filtered) {
			l.filtered = false;
			graph.links1.push(l);
		} else if ((l.source.filtered || l.target.filtered) && !l.filtered) {
			l.filtered = true;
			graph.links1.forEach(function(d, i) {
				if (l === d) {
					graph.links1.splice(i, 1);
				}
			});
		}
	});			
}

</script>
